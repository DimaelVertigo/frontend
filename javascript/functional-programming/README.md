# Functional programming

#### Чистота

Если говорится о чистоте в функциональном программировании, значит подразумеваются чистые функции.

Чистые функции — очень простые. Они всего лишь производят операция над входными данными.

Вот пример чистой функции:

```javascript
var z = 10;
function add(x, y) {
    return x + y;
}
```

Заметьте, что функция `add` не прикасается к переменной `z`. Она не читает её значения и ничего не пишет в неё. Функция читает только `x`и `y`, свои входные данные, и возвращает результат их суммы.

Это и есть чистая функция. Если функция `add` имеет доступ к переменной `z`, она больше не может быть чистой.

Это пример другой чистой функции:

```javascript
function justTen() {
    return 10;
}
```

Если функция `justTen` чистая, она может возвращать только значение-константу. Почему?

Потому что мы не даём ей никаких входных данных. А значит, чтобы быть чистой, она не должна изменять никаких переменных, кроме тех, что были ей переданы. Единственное, что может возвратить такая функция — константа.

Пока функции, не принимающие параметров, не работают, они не очень полезны. Было бы лучше объявить `justTen` просто как константу.

> Более **полезные** чистые функции принимают хотя бы один параметр.

Взгляните на этот пример:

```javascript
function addNoReturn(x, y) {
    var z = x + y
}
```

Посмотрите, эта функция ничего не возвращает. Она складывает `x` и `y`, записывает результат в переменную `z`, но не возвращает её.

Эта чистая функция работает только с входными данными. Да, она выполняет сложение, но пока обратно возвращается ничего, функция бесполезна.

> Все **полезные** чистые функции должны возвращать что-нибудь.

Давайте рассмотрим пример с первой функцией `add` ещё раз:

```javascript
function add(x, y) {
    return x + y;
}
console.log(add(1, 2)); // выводит 3
console.log(add(1, 2)); // всё ещё выводит 3
console.log(add(1, 2)); // БУДЕТ ВСЕГДА выводить 3
```

Обратите внимание, что `add(1, 2)` в результате всегда даёт `3`. Конечно, сюрприз не большой, но это потому что функция чистая. Если бы функция `add` брала значение откуда-то снаружи, вы бы _**никогда**_ не могли наверняка предсказать её поведение.

> Чистая функция **всегда** возвращает одинаковые значения для одинаковых входных данных_._

Поскольку чистые функции не могут изменять внешние переменные, все эти функции являются _**нечистыми**_:

```javascript
writeFile(fileName);
updateDatabaseTable(sqlCmd);
sendAjaxRequest(ajaxRequest);
openSocket(ipAddress);
```

Все функции в примере имеют то, что называют _**побочными эффектами**_. Когда Вы вызываете их, они меняют файлы и таблицы баз данных, отправляют данные на сервер или обращаются к операционной системе, чтобы получить сокет. Они делают куда больше, чем просто оперирование входными данными и возвращение значений. Следовательно, вы никогда не можете предсказать, что функция возвратит.

> Чистые функции **не** имеют побочных эффектов.

В таких языках императивного программирования как JavaScript, Java и C\# побочные эффекты _**везде**_. Это делает отладку проблематичной, потому что в коде Вашей программы переменная может быть изменена _**где угодно**_. В общем, если у Вас баг из-за переменой, принявшей неверное значение в неподходящее время, где Вы будете искать ошибку? Везде? Так дело не пойдёт.

На этом месте, вы, вероятно, думаете: “КАК, ЧЁРТ ПОБЕРИ, Я СДЕЛАЮ ХОТЬ ЧТО-НИБУДЬ **ОДНИМИ ТОЛЬКО** ЧИСТЫМИ ФУНКЦИЯМИ?”.

В функциональном программировании вы не пишите только чистые функции.

Функциональные языки не могут исключить побочных эффектов, они могут только изолировать их. Пока у программ будут интерфейсы, взаимодействующие с реальным миром, некоторые части любой программы должны быть нечистыми. Цель — это свести к минимуму количество нечистого кода и отделить его от остальной части программы.

#### Неизменяемость <a id="dd48"></a>

Вы помните, когда впервые увидели следующий код:

```javascript
var x = 1;
x = x + 1;
```

И тот, кто учил вас программированию, говорил забыть изученное на уроках математики. Ведь в математике `x` никогда не мог равняться `x + 1`.

Но в императивном программировании данный код означает «взять текущее значение `x`, прибавить к нему `1`, положить результат _обратно в_ `x`».

Что ж, в функциональном программировании выражение `x = x + 1`недопустимо. Так что Вам надо _**вспомнить**_ то, что вы _**забыли**_ из математики... Если так можно выразиться.

> В функциональном программировании **нет** переменных.

Сохранённые значения всё ещё называются переменными по историческим причинам, но они являются константами, то есть _**x**_, однажды приняв какое-либо значение, сохраняет его на всю жизнь.

Не волнуйтесь, `x` – это обычно локальная переменная, так что её жизнь достаточно коротка. Но пока она жива, она никак не изменится.

Вот пример переменной-константы в Elm — чистом языке функционального программирования для web-разработки:

```javascript
addOneToSum y z =
    let
        x = 1
    in
        x + y + z
```

Если вы не знакомы с синтаксисом семейства языков программирования ML, позвольте мне объяснить. `addOneToSum` – это функция, принимающая 2 параметра: `y` и `z`.

Внутри блока `let` `x` приписывается значение `1`, то есть он равен `1` до конца своей жизни. Его жизнь кончается, когда происходит выход из функции, или, более точно, когда исполняется блок `let`.

Внутри блока `in` вычисления могут включать значения, объявленные в блоке `let`, а именно: `x`. Возвращается результат вычисления `x + y + z` или, в точности, возвращается `1 + y + z`, так как `x = 1`.

И снова я могу услышать, как вы вопрошаете: “КАК, ЧЕРТ ПОБЕРИ, Я ДОЛЖЕН СДЕЛАТЬ ХОТЬ ЧТО-НИБУДЬ БЕЗ ПЕРЕМЕННЫХ?!”.

Давайте подумаем, когда обычно мы хотим изменить переменную. Всего две основных причины, которые приходят на ум: многозначные изменения \(например, изменение отдельного значения объекта или записи\) и однозначные изменения \(например, счётчики цикла\).

Функциональное программирование решает проблему изменений значения записи, делая копию уже изменённой записи. Это происходит оперативно, без копирования всех частей записи, используя определённые структуры данных, делающие это возможным.

Функциональное программирование решает также проблему однозначных изменений переменных, в сущности, тем же путём, просто делая их копию.

Да, кстати, и всё это _**без**_ циклов.

“СНАЧАЛА БЕЗ ПЕРЕМЕННЫХ, А ТЕПЕРЬ ЕЩЁ И БЕЗ ЦИКЛОВ? Я ТЕБЯ НЕНАВИЖУ!!!”

Попридержите коней. Это не значит, что мы не можем использовать циклы, просто здесь нет таких характерных операторов как `for`, `while`, `do`, `repeat` и так далее.

> Функциональное программирование использует рекурсию для выполнения цикла.

Вот два примера реализации цикла в JavaScript.

```javascript
// простой оператор цикла
var acc = 0;
for (var i = 1; i <= 10; ++i)
    acc += i;
console.log(acc); // выводит 55
```

```javascript
// без оператора цикла или переменных (рекурсия)
function sumRange(start, end, acc) {
    if (start > end)
        return acc;
    return sumRange(start + 1, end, acc + start)
}
console.log(sumRange(1, 10, 0)); // выводит 55
```

Обратите внимание, как рекурсия в функциональном подходе осуществляет то же самое, что и оператор цикла `for`, вызывая саму себя с _новым_ параметром запуска `(start + 1)` и с _новым_ счетчиком `(acc + start)`. Она не изменяет старых значений. Вместо этого она использует новые значения, высчитанные из старых.

К сожалению, такие примеры не очевидны в JavaScript \(даже если вы потратили некоторое время на их изучение\) по двум причинам. Во-первых, синтаксис JavaScript засорён, а во-вторых, вы, вероятно, не привыкли думать рекурсивно.

Пример на языке Elm читать и, следовательно, понимать легче:

```javascript
sumRange start end acc =
    if start > end then
        acc
    else
        sumRange (start + 1) end (acc + start)
```

Так этот код выполняется:

```javascript
sumRange 1 10 0 =      -- sumRange (1 + 1)  10 (0 + 1)
sumRange 2 10 1 =      -- sumRange (2 + 1)  10 (1 + 2)
sumRange 3 10 3 =      -- sumRange (3 + 1)  10 (3 + 3)
sumRange 4 10 6 =      -- sumRange (4 + 1)  10 (6 + 4)
sumRange 5 10 10 =     -- sumRange (5 + 1)  10 (10 + 5)
sumRange 6 10 15 =     -- sumRange (6 + 1)  10 (15 + 6)
sumRange 7 10 21 =     -- sumRange (7 + 1)  10 (21 + 7)
sumRange 8 10 28 =     -- sumRange (8 + 1)  10 (28 + 8)
sumRange 9 10 36 =     -- sumRange (9 + 1)  10 (36 + 9)
sumRange 10 10 45 =    -- sumRange (10 + 1) 10 (45 + 10)
sumRange 11 10 55 =    -- 11 > 10 => 55
55
```

Вам скорее всего кажется, что циклы `for` гораздо легче для понимания. Хотя это спорно и скорее всего является вопросом _**осведомлённости**_, не-рекурсивные циклы подразумевают изменчивость, что по своей сути плохо.

Я не объясняю здесь преимущества использования парадигмы неизменяемости, но вы можете посмотреть параграф под названием _**Global Mutable State**_ в статье [Why Programmers Need Limits](https://medium.com/@cscalfani/why-programmers-need-limits-3d96e1a0a6db), если хотите изучить эту тему.

Одно очевидное преимущество — то, что если вы имеете доступ к какому-либо значению в вашей программе, это доступ только для чтения, а значит никто другой не может изменить это значение. Даже вы сами. Вследствие, никаких случайных изменений.

Также, если программа многопоточная, исполнение никакого потока не разрушит ваши планы. Поскольку значение — константа и если поток захочет изменить его, ему придётся создать новое значение из старого.

Ещё в середине девяностых я написал игровой движок для [Creator Crunch](https://www.youtube.com/watch?v=uIOYSjBRORM) и самый большой источник ошибок был связан с вопросом многопоточности. Я хотел бы знать про неизменяемость в то время. Но тогда меня больше волновала разница между двух и четырёх скоростными приводами CD-ROM при игре.

> Неизменяемость делает код проще и безопаснее.

Дружеское напоминание

![](https://cdn-images-1.medium.com/max/1600/0*XJAU_lw3QmW5p-lW.)

Пожалуйста, читайте код медленно. Перед тем, как двигаться дальше, убедитесь, что вы всё поняли. Каждая следующая часть главы отталкивается от предыдущей.

Если вы будете спешить, то наверняка упустите некоторые нюансы, которые могут быть важны в дальнейшем.

#### Рефакторинг <a id="05ae"></a>

![](https://cdn-images-1.medium.com/max/1600/0*ZBGiOpPkx_6z0CNA.)

Давайте чуть-чуть подумаем о рефакторинге. Вот пример JavaScript-кода:

```javascript
function validateSsn(ssn) {
    if (/^\d{3}-\d{2}-\d{4}$/.exec(ssn))
        console.log('Valid SSN');
    else
        console.log('Invalid SSN');
}
```

```javascript
function validatePhone(phone) {
    if (/^\(\d{3}\)\d{3}-\d{4}$/.exec(phone))
        console.log('Valid Phone Number');
    else
        console.log('Invalid Phone Number');
}
```

Мы все писали такой код и лишь потом начинали понимать, что эти две функции практически одинаковые и отличаются только несколькими моментами \(выделены **жирным** шрифтом\).

Вместо копирования `validateSsn` и последующим её редактированием для получения `validatePhone`, нам лучше создать отдельную функцию и параметризировать данные.

В этом примере мы будет параметризировать _**входное значение**_, _**регулярное выражение**_ и _**сообщение**_ \(по крайней мере, последнюю его часть\).

Код после рефакторинга:

```javascript
function validateValue(value, regex, type) {
    if (regex.exec(value))
        console.log('Valid ' + type);
    else
        console.log('Invalid ' + type);
}
```

Параметры `ssn` и `phone` из старого примера теперь представлены как `value`.

Регулярные выражения `/^\d{3}-\d{2}-\d{4}$/` и `/^\(\d{3}\)\d{3}-\d{4}$/` – как `regex`.

И наконец, последние части сообщения `'SSN'` и `'Phone Number'` – как `type`.

Всегда лучше иметь одну функцию вместо двух. Или и того хуже: трёх, четырёх или десяти функций. Это делает ваш код чистым и удобным в поддержке.

Для примера: если возникает ошибка, вам нужно исправить её в одном-единственном месте в сравнении с тем, чтобы искать по всему исходному коду, куда эта функция МОГЛА БЫТЬ вставлена и переделана.

Но что происходит, когда у нас появляется следующая ситуация:

```javascript
function validateAddress(address) {
    if (parseAddress(address))
        console.log('Valid Address');
    else
        console.log('Invalid Address');
}
```

```javascript
function validateName(name) {
    if (parseFullName(name))
        console.log('Valid Name');
    else
        console.log('Invalid Name');
}
```

Здесь `parseAddress` и `parseFullName` – функции, принимающие строку и возвращающие `true`, если она парсится.

Как произвести рефакторинг в этом случае?

Что ж, мы можем использовать `value` для `adress` и `name` и `type` для `'Address'` и `'Name'`, как мы делали это раньше, но вместо регулярного выражения здесь функция.

Единственный выход — передавать функцию параметром…

#### Функции высшего порядка <a id="209f"></a>

![](https://cdn-images-1.medium.com/max/1600/0*Ry_KbY_sTX0c9c2U.)

Многие языки не поддерживают передачу функций в качестве параметров. Некоторые — поддерживают, но проще от этого не становится.

> В функциональном программировании функция — это полноправный гражданин языка. Иными словами, функция — всего лишь другое значение.

Пока функции являются просто значениями, мы можем передавать их как параметры.

Хотя JavaScript — это не чистый функциональный язык, вы можете выполнять с помощью него некоторые функциональные операции. Вот последние две функции, преобразованные в одну отдельную с помощью передачи _**функции-парсера**_ в качестве параметра, называющегося `parseFunc`.

```javascript
function validateValueWithFunc(value, parseFunc, type) {
    if (parseFunc(value))
        console.log('Valid ' + type);
    else
        console.log('Invalid ' + type);
}
```

Наша новая функция называется _**функцией высшего порядка**_.

> Функции высшего порядка либо принимают функции как параметры, либо возвращают их, либо и то, и другое одновременно.

Теперь мы можем вызвать нашу функцию высшего порядка для четырёх предыдущих функций \(это работает в JavaScript, потому что `Regex.exec` возвращает истинное значение, если находится совпадение\):

```javascript
validateValueWithFunc('123-45-6789', /^\d{3}-\d{2}-\d{4}$/.exec, 'SSN');
validateValueWithFunc('(123)456-7890', /^\(\d{3}\)\d{3}-\d{4}$/.exec, 'Phone');
validateValueWithFunc('123 Main St.', parseAddress, 'Address');
validateValueWithFunc('Joe Mama', parseName, 'Name');
```

Это гораздо лучше, чем иметь четыре практически идентичных функций.

Но обратите внимание на регулярные выражения. Они немного пространные. Давайте приведём наш код в порядок, реорганизовав его таким образом:

```javascript
var parseSsn = /^\d{3}-\d{2}-\d{4}$/.exec;
var parsePhone = /^\(\d{3}\)\d{3}-\d{4}$/.exec;
```

```javascript
validateValueWithFunc('123-45-6789', parseSsn, 'SSN');
validateValueWithFunc('(123)456-7890', parsePhone, 'Phone');
validateValueWithFunc('123 Main St.', parseAddress, 'Address');
validateValueWithFunc('Joe Mama', parseName, 'Name');
```

Так-то лучше. Теперь, когда мы хотим пропарсить телефонный номер, нам не нужно копировать и вставлять регулярные выражения.

Но представьте, что у нас гораздо больше регулярных выражений для парсинга, а не только `parseSsn` и `parsePhone`. Каждый раз, когда мы создаем парсер регулярным выражением, мы должны помнить о том, чтобы добавить `.exec` в конце. И уж поверьте мне, это легко забыть.

Мы можем застраховаться от этого, создав функцию высшего порядка, возвращающую метод `exec`.

```javascript
function makeRegexParser(regex) {
    return regex.exec;
}
```

```javascript
var parseSsn = makeRegexParser(/^\d{3}-\d{2}-\d{4}$/);
var parsePhone = makeRegexParser(/^\(\d{3}\)\d{3}-\d{4}$/);
```

```javascript
validateValueWithFunc('123-45-6789', parseSsn, 'SSN');
validateValueWithFunc('(123)456-7890', parsePhone, 'Phone');
validateValueWithFunc('123 Main St.', parseAddress, 'Address');
validateValueWithFunc('Joe Mama', parseName, 'Name');
```

В этом примере `makeRegexParser` принимает регулярное выражение и возвращает метод `exec`, который в свою очередь принимает строку. `validateValueWithFunc` будет передавать строку, `value`, методу-парсеру, то есть `exec`.

`parseSsn` и `parsePhone` эффективны также, как и раньше, и также, как и метод `exec` регулярных выражений.

Честно говоря, это незначительное улучшение, но оно показано здесь, чтобы привести пример функции высшего порядка, возвращающей функцию \(_прим. пер., методы — тоже функции_\).

Несмотря на это, вы можете представить пользу от подобных изменений, если бы `makeRegexParser` была гораздо более комплексной.

Вот другой пример функции высшего порядка, возвращающей функцию:

```javascript
function makeAdder(constantValue) {
    return function adder(value) {
        return constantValue + value;
    };
}
```

Здесь у нас есть `makeAdder`, принимающая `constantValue` и возвращающая `adder` - функцию, которая будет добавлять значение-константу к любой переданной ей переменной.

Вот как её можно использовать:

```javascript
var add10 = makeAdder(10);
console.log(add10(20)); // печатает 30
console.log(add10(30)); // печатает 40
console.log(add10(40)); // печатает 50
```

Мы создаём функцию, `add10`, передавая константу `10` функции `makeAdder`, которая возвращает функцию, которая в свою очередь будет добавлять `10`.

Заметьте, что функция `adder` имеет доступ к `constantValue` даже после того, как `makeAdder` возвращает своё значение. Это потому, что `constantValue` уже находилась в её области видимости в тот момент, когда `adder` была создана.

Такое поведение очень значимо, так как без него функции, возвращающие функции, не были бы настолько полезными. Так что важно понимать, как они работают и как такое поведение называется.

А называется оно _**замыканием**_.

#### Замыкания <a id="7bc7"></a>

![](https://cdn-images-1.medium.com/max/1600/0*nbzNwdIzTwSbrpiZ.)

Вот специально придуманный пример функций, использующих замыкание:

```javascript
function grandParent(g1, g2) {
    var g3 = 3;
    return function parent(p1, p2) {
        var p3 = 33;
        return function child(c1, c2) {
            var c3 = 333;
            return g1 + g2 + g3 + p1 + p2 + p3 + c1 + c2 + c3;
        };
    };
}
```

В этом примере `child` имеет доступ к своим локальным переменным, к переменным `parent` и к переменным `grandParent`.

`parent` имеет доступ к своим переменным и к переменным `grandParent`.

`grandParent` имеет доступ только к своим переменным.

\(Смотрите на пирамиду выше для ясности.\)

Вот пример использования всего этого:

```coffeescript
var parentFunc = grandParent(1, 2); // возвращает parent()
var childFunc = parentFunc(11, 22); // возвращает child()
console.log(childFunc(111, 222)); // печатает 738
// 1 + 2 + 3 + 11 + 22 + 33 + 111 + 222 + 333 == 738
```

Здесь `parentFunc` хранит область видимости `parent`, потому что `grandParent` возвращает `parent`.

Таким же образом `childFunc` хранит область видимости `child`, потому что `parentFunc`, по сути являющийся `parent`, возвращает `child`.

Когда создана функция, все переменные в её области видимости в момент создания доступны ей на время жизни. Функция существует, пока на неё есть ссылка. Для примера, область видимости `child`существует, пока `childFunc` продолжает ссылаться на неё.

> Замыкание — область видимости функции, которая сохраняется благодаря ссылке на эту функцию.

Обратите внимание, что замыкания в JavaScript — сомнительное удовольствие из-за изменяемости переменных, то есть из-за того, что они могут менять своё значение с момента определения и до тех пор, пока вызываемая функция не возвратится.

К счастью, переменные в функциональных языках программирования неизменяемые, что устраняет этот общий источник ошибок и неопределённости.

#### Композиция функций <a id="46fa"></a>

![](https://cdn-images-1.medium.com/max/1600/0*FoaFKHXsiN515OdU.)

Как все нормальные программисты, мы — ленивые. Мы не хотим постоянно собирать, тестировать и деплоить один и тот же код, который переписываем снова, и снова, и снова.

Мы всегда пытаемся найти пути, чтобы, решив какую-нибудь задачу однажды, использовать это решение в других случаях.

Повторное использование кода — хорошая затея, но в реальности этого тяжело добиться. Попробуйте сделать код слишком специализированным и у вас не получится использовать его снова. Попробуйте сделать его слишком общим и вам будет сложно использовать его даже в вашей первоочередной задаче.

То, что нам нужно — баланс между этими двумя положениями, споcоб создавать элементы поменьше с возможностью их многократного использования, которые мы будем применять как строительные блоки для конструирования более сложного функционала.

В функциональном программировании функции — наши строительные блоки. Мы пишем их для решения определённых задач, а потом складываем вместе, как блоки в Lego™.

Результат такого сложения называется _**композицией функций**_.

Так как же это работает? Давайте начнём с двух JavaScript-функций:

```javascript
var add10 = function(value) {
    return value + 10;
};
var mult5 = function(value) {
    return value * 5;
};
```

Код получился слишком пространный, так что давайте перепишем его, используя [стрелочные функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions):

```javascript
var add10 = value => value + 10;
var mult5 = value => value * 5;
```

Так-то лучше. Теперь давайте представим, что нам нужна функция, принимающая значение и добавляющая к нему 10, после чего умножающая результат на 5. Мы могли бы написать:

```javascript
var mult5AfterAdd10 = value => 5 * (value + 10)
```

Даже несмотря на такой простой пример, нам бы не хотелось писать целую функцию с нуля. Во-первых, мы могли бы допустить ошибку и, например, забыть поставить круглые скобки.

Во-вторых, у нас есть одна функция, прибавляющая к значению 10, и другая, умножающая его на 5. Получается, мы пишем код, который уже написали.

Так что вместо этого давайте используем `add10` и `mult5` и соберём новую функцию:

```javascript
var mult5AfterAdd10 = value => mult5(add10(value));
```

Мы просто использовали существующие функции, чтобы получить `mult5AfterAdd10`, но есть и способ получше.

В математике _**f ∘ g**_ — композиция функций \(_прим. пер., или суперпозиция функций_\) и читается она как «_**применение функции f к результату функции g**_» или более просто «_**выполнение f после g**_». Получается, что _**\(f ∘ g\)\(x\)**_ — эквивалент вызова функции _**f**_после функции _**g**_ со значением _**x**_ или ещё проще: `f(g(x))`.

В нашем примере у нас `mult5` ∘ `add10` или «`mult5` _**после**_ `add10`», отсюда и название нашей функции `mult5AfterAdd10`.

И это объясняет то, что мы сделали. Мы вызвали `mult5` после вызова `add10` с `value` или просто: `mult5(add10(value))`.

Поскольку JavaScript нативно не реализует возможность композиции функций, давайте взглянем на Elm:

```javascript
add10 value =
    value + 10
```

```javascript
mult5 value =
    value * 5
```

```javascript
mult5AfterAdd10 value =
    (mult5 << add10) value
```

В Elm функции компонуются с помощью инфиксального оператора `<<`. Это даёт нам визуально понять как параметры из одной функции «перетекают» в другую. Сначала `value` попадает в `add10`, а затем её результат попадает в `mult5`.

Обратите внимание на скобки в `mult5AfterAdd10`, то есть именно на выражение `(mult5 << add10)`. Они там затем, чтобы быть уверенными, что `value` будет передана внутрь выражения после того, как функции в нём скомпонуются.

Вы можете скомпоновать столько функций, сколько захотите, например:

```javascript
f x =
   (g << h << s << r << t) x
```

В этом случае `x` передаётся в `t`, чей результат передаётся в `r`, чей результат, в свою очередь, — в `s` и так далее. Если вы захотите сделать что-то подобное в JavaScript, это будет выглядеть примерно так: `g(h(s(r(t(x)))))` — просто какой-то ад из круглых скобок.

#### Бесточечная нотация <a id="6745"></a>

![](https://cdn-images-1.medium.com/max/1600/0*AUNkMfxptUzWWhEi.)

_**Бесточечная нотация**_ — стиль описания функций без предварительного указания входных параметров. По началу такой стиль будет казаться необычным, но по мере продолжения, когда вы достаточно разберётесь, вы оцените лаконичность такого подхода.

Вы заметите, что в `mult5AfterAdd10` значение `value` определяется дважды. Один раз в списке параметров и один раз в момент использования.

```javascript
-- Эта функция ожидает 1 входной параметр

mult5AfterAdd10 value =
    (mult5 << add10) value
```

Но этот параметр несущественен, так как `add10`, самая правая функция в композиции, ожидает тот же параметр. Следующая бесточечная версия — эквивалент предыдущей:

```javascript
-- Эта функция тоже ожидает 1 входной параметр

mult5AfterAdd10 =
    (mult5 << add10)
```

В использовании такого бесточечного подхода существует множество преимуществ.

Во-первых, нам не нужно определять лишние параметры. И поскольку мы их не определяем, нам также не нужно придумывать им имена.

Во-вторых, код становится легче читать и анализировать, так как он более лаконичный. Это простой пример, но представьте функцию, принимающую больше параметров.

#### «Тени в раю» <a id="7b06"></a>

![](https://cdn-images-1.medium.com/max/1600/0*RhofKVc0-ENP6vF0.)

До сих пор мы разбирались, как работает композиция функций, и как следует определять функции при бесточечной нотации для лаконичности, чистоты и гибкости кода.

Теперь давайте попробуем использовать эти идеи при слегка ином сценарии и посмотрим, насколько они ему соответствуют. Представьте, что мы заменяем `add10` на `add`:

```javascript
add x y =    x + y
mult5 value =    value * 5
```

Как нам создать `mult5AfterAdd10`, используя эти две функции?

Ладно, если вы действительно потратите время, раздумывая над этим вопросом, то вернётесь примерно с таким решением:

```text
-- Это неверно !!!!
```

```javascript
mult5AfterAdd10 =
    (mult5 << add) 10
```

Но такой код не будет работать. Потому что `add` принимает два параметра.

Если это не так очевидно в Elm, попробуйте написать то же самое в JavaScript:

```javascript
var mult5AfterAdd10 = mult5(add(10)); // не работает
```

Этот код неверен, но почему?

Потому что в нём функция `add` принимает лишь один из своих двух параметров, после чего передаёт ошибочные результаты в `mult5`. Это будет приводить к неверным решениям.

По факту, в Elm компилятор не позволит вам даже написать такой нецелесообразный код \(что является одним из больших плюсов языка Elm\).

Давайте попробуем ещё раз:

```javascript
var mult5AfterAdd10 = y => mult5(add(10, y)); // не бесточечный стиль
```

Да, это не бесточечный стиль, но я тем не менее могу жить с таким решением. В то же время, теперь я уже не просто комбинирую функции. Я пишу новую функцию. Также, если задача станет гораздо сложнее, к примеру, если я захочу скомпоновать `mult5AfterAdd10` с какой-то другой функцией, я столкнусь с серьёзной проблемой.

Пока мы не можем «обвенчать» эти две функции, будет казаться, что идея композиции функций не обладает такой уж большой практической ценностью. И это очень плохо, потому что на самом деле это не так.

Что ж, что было бы действительно хорошо, так это если бы у нас была идея, как _предварительно_ передать нашей функции `add` один из её входных параметров и уже _позже_ — второй параметр, когда будет вызвана `mult5AfterAdd10`.

Выходом из этого затруднительного положения является концепция _**каррирования**_.

Каррирование

![](https://cdn-images-1.medium.com/max/1600/0*6T0mPD4UNPAA3TQg.)

Как вы помните из [Части 3](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-3-d1f567656158), причиной проблемы, из-за которой нам не удавалось скомпоновать функции `mult5` и `add`, является тот факт, что `mult5` принимает один параметр, а `add` — целых два.

Мы можем очень легко решить эту проблему, уменьшив количество входных данных до одного для всех функций.

Поверьте мне. Это не так плохо, как звучит.

Мы просто пишем функцию сложения, использующую два входных параметра, но принимающую один за раз. _**Каррированные функции**_ позволяют нам сделать это.

> Каррированная функция— это функция, принимающая один аргумент за раз.

С их помощью мы передадим в `add` первый параметр перед тем, как скомпонуем её с `mult5`. Затем, когда `mult5AfterAdd10` будет вызвана, `add` получит свой второй параметр.

В JavaScript мы можем реализовать эту идею, переписав `add`:

```javascript
var add = x => y => x + y;
```

Этот вариант `add` — функция, принимающая один параметр сразу и второй — позже.

Более детально, функция `add` принимает отдельный параметр, `x`, и возвращает _**функцию**_, принимающую следующий отдельный параметр, `y`, который, в конечном счёте, будет возвращать **результат сложения `x` и `y`**.

Теперь мы можем использовать новый `add`, чтобы написать исправный вариант `mult5AfterAdd10`:

```javascript
var compose = (f, g) => x => f(g(x));
var mult5AfterAdd10 = compose(mult5, add(10));
```

Функция компоновки \(`compose`\) получает на вход два параметра: `f` и `g`. После чего она возвращает функцию, принимающую один параметр, `x`, с вызовом которой композиция функций _**`f` после `g`**_осуществится с аргументом `x`.

Так что же мы на самом деле сделали? Что ж, мы конвертировали нашу простую старую функцию `add` в её каррированный вариант. Это сделало `add` более гибкой, поскольку первый параметр, `10`, может быть передан перед непосредственным выполнением функции, а второй — когда `mult5AfterAdd10` будет вызвана.

Здесь вам, наверное, должно быть интересно, как же переписать функцию сложения для Elm. Оказывается, делать этого не нужно. В Elm и в других языках функционального программирования все функции автоматически каррированные.

Так что функция `add` остаётся неизменной:

```javascript
add x y =
    x + y
```

А вот как должна была быть написана `mult5AfterAdd10`, возвращаясь к [Части 3](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-3-d1f567656158):

```javascript
mult5AfterAdd10 =
    (mult5 << add 10)
```

Говоря о синтаксисе, Elm одерживает верх над такими императивными языками, как JavaScript, поскольку он изначально оптимизирован для различных задач функционального программирования, например, каррирования или композиции функций.

#### Каррирование и рефакторинг <a id="e362"></a>

![](https://cdn-images-1.medium.com/max/1600/0*0rvX6Yfeja76Da2b.)

Другой случай, когда каррирование способно показать себя во всей красе — процесс рефакторинга, во время которого вы создаёте универсальный вариант функции со множеством параметров, а потом используете её для создания более адаптированного варианта, но уже с меньшим количеством входных данных.

Допустим, для примера, что у нас есть следующие функции, обрамляющие строку одинарными и двойными скобками:

```javascript
bracket str =
    "{" ++ str ++ "}"
doubleBracket str =
    "{{" ++ str ++ "}}"
```

И вот, как мы их используем:

```javascript
bracketedJoe =
    bracket "Joe"
doubleBracketedJoe =
    doubleBracket "Joe"
```

Мы можем обобщить `bracket` и `doubleBracket`:

```javascript
generalBracket prefix str suffix =
    prefix ++ str ++ suffix
```

Но теперь при каждом вызове `generalBracket` мы должны передавать сами скобки входными значениями:

```javascript
bracketedJoe =
    generalBracket "{" "Joe" "}"
```

```javascript
doubleBracketedJoe =
    generalBracket "{{" "Joe" "}}"
```

Мы же в действительности хотим взять лучшее из обоих миров.

Если мы перегруппируем входные параметры в `generalBracket`, мы сможем создать `bracket` и `doubleBracket`, выгодно используя факт каррированных функций:

```javascript
generalBracket prefix suffix str = prefix ++ str ++ suffix
    
bracket = generalBracket "{" "}"

doubleBracket = generalBracket "{{" "}}"
```

Заметьте, что располагая статические параметры первыми, то есть `prefix` и `suffix`, а изменяемые параметры — последними, то есть `str`, мы можем легко создавать адаптированные варианты `generalBracket`.

> Порядок входных параметров очень важен для наиболее выгодного использования каррирования.

Кроме того заметьте, что функции `bracket` и `doubleBracket` написаны в бесточечном стиле, то есть аргумент `str` только предполагается. Обе функции — `bracket` и `doubleBracket` — ожидают свой последний параметр.

Теперь мы можем использовать их так, как и хотели:

```javascript
bracketedJoe =
    bracket "Joe"
```

```javascript
doubleBracketedJoe =
    doubleBracket "Joe"
```

Но только теперь мы используем общую функцию каррирования — `generalBracket`.

#### Стандартные функции функционального программирования <a id="0eef"></a>

![](https://cdn-images-1.medium.com/max/1600/0*jdiPFssWUdOsxXB3.)

Давайте рассмотрим три стандартные функции, использующиеся в языках функционального программирования.

Но для начала обратим внимание на следующий JavaScript-код:

```javascript
for (var i = 0; i < something.length; ++i) {
    // do stuff
}
```

Этот код содержит одну существенную вредную особенность. И это не ошибка. Проблема в том, что это шаблонный код, то есть код, использующийся снова и снова.

Если вы пишете на императивном языке, как Java, C\#, JavaScript, PHP, Python и так далее, вы найдете у себя этот шаблон повторяющимся чаще, чем любой другой.

Именно это с этим кодом и не так.

Так избавимся же от него. Давайте обернём его в функцию \(или несколько функций\) и никогда больше не будет писать цикл `for`снова. Ну, то есть почти никогда; по крайней мере, до тех пор, пока полностью не перейдем на функциональное программирование.

```javascript
var things = [1, 2, 3, 4];
for (var i = 0; i < things.length; ++i) {
    things[i] = things[i] * 10; // ТРЕВОГА: ИЗМЕНЕНИЕ ДАННЫХ !!!!
}
console.log(things); // [10, 20, 30, 40]
```

Вот чёрт! Изменяемость!

Попробуем-ка ещё раз. В этот раз мы не будем изменять `things`:

```javascript
var things = [1, 2, 3, 4];
var newThings = [];
for (var i = 0; i < things.length; ++i) {
    newThings[i] = things[i] * 10;
}
console.log(newThings); // [10, 20, 30, 40]
```



Так, ладно, мы не изменили `things`, но технически мы изменили `newThings`. Пока что пропустим это мимо глаз. Всё-таки мы в мире JavaScript. Однажды коснувшись идей функционального программирования, нам больше не хочется прибегать к изменяемости.

На данном этапе важно понять, как эти функции работают и помогают нам уменьшить «шум» в нашем коде.

Давайте возьмём этот код и положим его в функцию. Мы назовём нашу первую стандартную функцию _**map**_ \(_прим. пер., английский глагол «наносить на карту»_\), так как она переносит каждое значение из старого массива в новое значение в новом массиве:

```javascript
var map = (f, array) => {
    var newArray = [];
    for (var i = 0; i < array.length; ++i) {
        newArray[i] = f(array[i]);
    }
    return newArray;
};
```

Обратите внимание, что функция, `f`, передаётся вовнутрь, и это позволяет нашей функции `map` делать всё, что нам захочется с каждым элементом массива.

Теперь мы можем переписать предыдущий код, используя `map`:

```javascript
var things = [1, 2, 3, 4];
var newThings = map(v => v * 10, things);
```

«Мама, мама, посмотри, я написал код без цикла `for`!». Теперь его легче читать и, следовательно, анализировать.

Что ж, технически, цикл `for` всё ещё есть в функции `map`. Но зато теперь мы свободны от постоянного повторения этого шаблонный кода.

Теперь давайте напишем другую стандартную функцию, _**фильтрующую**_ объекты в массиве:

```javascript
var filter = (pred, array) => {
    var newArray = [];
for (var i = 0; i < array.length; ++i) {
        if (pred(array[i]))
            newArray[newArray.length] = array[i];
    }
    return newArray;
};
```

Заметьте, что если функция-предикат, `pred`, возвращает _TRUE_, мы сохраняем элемент, а если _FALSE_ — выбрасываем его.

Вот как можно применить `filter` для фильтрации нечётных чисел:

```javascript
var isOdd = x => x % 2 !== 0;
var numbers = [1, 2, 3, 4, 5];
var oddNumbers = filter(isOdd, numbers);
console.log(oddNumbers); // [1, 3, 5]
```

Использовать наш новый `filter` гораздо проще, чем вручную постоянно переписывать его с помощью цикла `for`.

Последняя стандартная функция называется _**reduce**_ \(_прим. пер., английский глагол «уменьшать»_\). Как правило, она используется, когда надо взять список и свести его к одному значению, но, на самом деле, её возможности куда шире.

Обычно в функциональных языках эта функция носит название _**fold**_\(_прим. пер., английский глагол «свёртывать» или «складывать»_\).

```javascript
var reduce = (f, start, array) => {
    var acc = start;
    for (var i = 0; i < array.length; ++i)
        acc = f(array[i], acc); // f() принимает 2 аргумента
    return acc;
});
```

Функция `reduce` принимает функцию свёртки, `f`, исходное значение, `start`, и `array`.

Имейте в виду, что функция свёртки, `f`, принимает два параметра: текущий элемент массива `array` и аккумулятор`acc`. Она будет использовать эти параметры для обновления аккумулятора каждую новую итерацию. Значение аккумулятора в момент последней итерации будет возвращено из функции.

Вот пример, который поможет нам понять, как это работает:

```javascript
var add = (x, y) => x + y;
var values = [1, 2, 3, 4, 5];
var sumOfValues = reduce(add, 0, values);
console.log(sumOfValues); // 15
```

Заметьте, что функция `add` принимает два параметра и складывает их. Наша функция `reduce` как раз ожидает функцию, принимающую два параметра, так что они хорошо сработаются вместе.

Мы начинаем со значения `start`, равного нулю, и шаг за шагом суммируем значения нашего массива `values`. С каждой новой итерацией сумма внутри функции `reduce` увеличивается. И, в конце концов, накопленное значение возвращается как `sumOfValues`.

Каждая из этих функций, `map`, `filter` и `reduce`, упрощает нам работу с массивами и освобождает от скучного повторения шаблонных циклов `for`.

Но в функциональном программировании они ещё более ценны, поскольку в случаях, когда требуется прибегнуть к цикличности, сложно ограничиться одними рекурсиями. Итеративные функции не просто чрезвычайно полезны. Они просто необходимы.

Прозрачность ссылок

![](https://cdn-images-1.medium.com/max/1600/0*0VoysYyVsxr2PPS0.)

_**Прозрачность ссылок**_ \(_прим. пер., референциальная прозрачность или прозрачность подстановки_\) — выдуманный термин для описания возможности безопасной замены чистых функций их выражением. Пример наглядно продемонстрирует это.

В алгебре, когда у вас есть следующая формула:

```javascript
y = x + 10
```

И утверждается, что:

```javascript
x = 3
```

Вы можете подставить `x` обратно в уравнение, чтобы получить:

```javascript
y = 3 + 10
```

Заметьте, что уравнение остаётся истинным. Мы можем делать подобные замены с чистыми функциями.

Вот функция на Elm, обособляющая одинарными кавычками входящую строку:

```javascript
quote str =
    "'" ++ str ++ "'"
```

И вот код, использующий её:

```javascript
findError key =
    "Unable to find " ++ (quote key)
```

В этом примере `findError` создаст сообщение об ошибке, если поиск `key` не увенчался успехом.

Пока функция `quote` чистая, мы можем просто переместить вызов функции в `findError` вместе с телом функции `quote` \(которое, по сути, является выражением\):

```javascript
findError key =
   "Unable to find " ++ ("'" ++ key ++ "'")
```

Это то, что я называю _**обратным рефакторингом**_ \(_прим. пер., инлайнингом_\)\(сюда я вкладываю достаточно широкий смысл\) — процессом, который может использоваться программистами или программами \(такими как компиляторы или приложения для тестов\), чтобы более осмысленно анализировать код.

Это может быть особенно полезным при анализе рекурсивных функций.

#### Порядок выполнения <a id="24b6"></a>

![](https://cdn-images-1.medium.com/max/1600/0*beeYrqJzFOGUdJvC.)

Большинство программ однопоточные, то есть одна и только одна часть кода выполняется за определённый промежуток времени. Даже если у вас многопоточная программа, большинство потоков блокируется ожиданием выполнения процессов ввода-вывода, например, загрузкой файла, ответом сети и так далее.

Это одна из причин, почему мы должны мыслить категориями пошаговой инструкции, когда пишем код:

```text
1. Достать хлеб
2. Положить два ломтика в тостер
3. Выбрать максимальную обжарку
4. Опустить рычаг
5. Подождать, пока тосты не вылетят
6. Вынуть тосты
7. Достать масло
8. Взять нож для масла
9. Намазать масло на тосты
```

В этом примере есть две независимые операции: использование масла и приготовление тостов. Они становятся взаимозависимыми только на девятом шаге.

Мы можем осуществить шаги семь и восемь параллельно с первым по шестой, пока они независимы один от другого.

Но, как только мы сделаем это, всё сильно усложнится:

```text
Поток 1
--------
1. Достать хлеб
2. Положить два ломтика в тостер
3. Выбрать максимальную обжарку
4. Опустить рычаг
5. Подождать, пока тосты не вылетят
6. Вынуть тосты
```

```text
Поток 2
--------
1. Достать масло
2. Взять нож для масла
3. Подождать, пока поток 1 не выполнится
4. Намазать масло на тосты
```

Что случится со вторым потоком, если нарушится первый? Каков механизм взаимодействия двух потоков? Какому потоку всё-таки принадлежат тосты: первому, второму или обоим?

Легче всего не думать об этих структурных сложностях и оставить нашу программу выполнятся одним потоком.

Однако, когда для нас важно выжать из программы всю возможную производительность, мы должны приложить титанические усилия, чтобы написать для неё многопоточный программный код.

Так или иначе, с многопоточностью есть две основные проблемы. Во-первых, многопоточные приложения сложно писать, анализировать, тестировать и отлаживать.

Во-вторых, такие языки, как JavaScript, не поддерживают многопоточность \(_прим. пер., статья была написана в уже далёком 2016 году, и сейчас у нас есть большая надежда в виде_ [_Napa.js_](https://github.com/Microsoft/napajs)\), а те некоторые, что поддерживают, делают это плохо.

Но что если порядок не имеет значения и всё может выполняться параллельно?

Несмотря на то, что это звучит ненормально, идея не настолько хаотична, насколько может показаться в начале. Давайте взглянем на следующий код Elm, иллюстрирующий это:

```javascript
buildMessage message value =
    let
        upperMessage =
            String.toUpper message
        quotedValue =
            "'" ++ value ++ "'"
    in
        upperMessage ++ ": " ++ quotedValue
```

Здесь `buildMessage` принимает `message` и `value`, затем приводит `message` к верхнему регистру, обрамляет `value` кавычками и конкатенирует эти строки, разделяя их символом двоеточия.

Заметьте, что `upperMessage` и `quotedValue` независимы друг от друга. Откуда нам известно это?

Для условия независимости есть всего две истины. Во-первых, обе функции должны быть чистыми. Это важно, поскольку при выполнении они не должны влиять друг на друга.

Если они не будут чистыми, мы никогда не сможем сказать наверняка, являются ли они независимыми. В этом случае, мы будем вынуждены ориентироваться на тот порядок выполнения, который они самостоятельно запустили. Так работают императивные языки программирования.

Во-вторых, следующее условие: результат выполнения одной функции не является входным значением другой. Если это не так, нам придётся ждать конца выполнения первой функции, чтобы запустилась вторая.

В таком ключе, `upperMessage` и `quotedValue` - обе чистые функции и ни одна из них не требует результата выполнения другой.

Следовательно, эти функции могут быть вызваны в ЛЮБОМ ПОРЯДКЕ.

Компилятор может определить порядок выполнения без какого-либо участия со стороны программиста. Это возможно только в чистом функциональном языке, потому как очень сложно, если вообще возможно, определять последствия побочных эффектов.

> Порядок выполнения кода в чистом функциональном языке программирования может быть самостоятельно определён компилятором.

Это чрезвычайно эффективно, учитывая, что процессоры не ускоряются. Вместо этого процесс обработки подключает всё больше и больше ядер. Это означает, что код может выполняться параллельно на аппаратном уровне.

К несчастью, с императивными языками мы не можем в полной мере использовать мощь этих ядер, кроме как на очень грубом уровне. Однако и для этого потребуется радикальным образом поменять архитектуру наших программ.

С чистым функциональным языком программирования у нас есть потенциал автоматически использовать преимущества ядер процессора на мелкомодульном уровне без изменения отдельной строки кода.

#### Аннотация типов <a id="c632"></a>

![](https://cdn-images-1.medium.com/max/1600/0*nmPVJeE0x9JbkMNX.)

В языках программирования со статической типизацией объявление типов — встроенная возможность. Вот пример Java-кода для иллюстрации:

```java
public static String quote(String str) {
    return "'" + str + "'";
}
```

Обратите внимание, как типизация встроена в само определение функции. Всё становится ещё туманнее, когда у вас появляются обобщения типов данных:

```java
private final Map<Integer, String> getPerson(Map<String, String> people, Integer personId) {
   // ...
}
```

Я отметил жирным шрифтом типы, которые выделяют их, но они всё равно продолжают запутывать определение функции. Вы должны читать аккуратно, чтобы найти имена переменных.

В языках с динамической типизацией такой проблемы не стоит. В JavaScript мы можем писать код вот так:

```javascript
var getPerson = function(people, personId) {
    // ...
};
```

Гораздо легче читать код без всякой надоедливой информации о типах. Единственная проблема в том, что мы теряем безопасность типизации. Мы можем просто передать параметры в обратном направлении, то есть _Number_ для `people` и _Object_ для `personId`.

Мы не сможем обнаружить ошибку до падения всего приложения, а это может случиться после нескольких месяцев прилежной работы на продакшене. Этого не произойдёт в Java, поскольку код там просто откажется компилироваться.

Но что, если мы можем взять лучшее из обоих миров. Синтаксическая простота JavaScript вместе с безопасностью Java.

Действительно, можем. Вот функция на Elm с аннотацией типов \(_прим. пер., сигнатурой типов_\):

```java
add : Int -> Int -> Int
add x y =
    x + y
```

Заметьте, что информация о типе находится на отдельной строке. Это разделение проводит грань различия с другими мирами.

Теперь вам, наверное, кажется, что в этой аннотации есть опечатка. Я помню, что сделал, когда впервые увидел её. Я подумал, что вместо первого `->` должна быть запятая. Но здесь нет опечатки.

Ситуация приобретёт для вас больше смысла, когда вы увидите аннотацию с подразумеваемыми круглыми скобками:

```text
add : Int -> (Int -> Int)
```

Здесь говорится, что `add` - это функция, принимающая _единственный_ параметр типа `Int`, а затем возвращающая функцию, принимающую _единственный_ параметр `Int` и возвращающую `Int`.

Вот другая аннотация типов с расставленными круглыми скобками:

```text
doSomething : String -> (Int -> (String -> String))
doSomething prefix value suffix =
    prefix ++ (toString value) ++ suffix
```

Здесь говорится, что `doSomething` - функция, принимающая _единственный_ параметр типа `String` и возвращающая функцию, которая принимает _единственный_ параметр типа `Int` и возвращающая функцию, принимающую _единственный_ параметр типа `String` и возвращающую `String`.

Заметьте, что всё получает _единственный_ параметр. Это потому что все функции в Elm автоматически каррированные.

Пока круглые скобки всегда подразумеваются в правой стороне выражения, они не обязательны. Так что мы можем просто написать:

```text
doSomething : String -> Int -> String -> String
```

Круглые скобки важны, когда мы передаём функцию входным параметром. Без них аннотация типов будет неясна. Для примера:

```text
takes2Params : Int -> Int -> String
takes2Params num1 num2 =
    -- do something
```

и это очень отлично от:

```text
takes1Param : (Int -> Int) -> String
takes1Param f =
    -- do something
```

`takes2Params` - это функция, требующая два параметра, `Int` и другой `Int`. В то время как, `takes1Param` требует одним входным параметром функцию, принимающую `Int` и другой `Int`.

Вот аннотация типов к `map`:

```text
map : (a -> b) -> List a -> List b
map f list =
    // ...
```

Здесь круглые скобки нужны, потому что `f` - функция с типом `(a -> b)`, то есть функция, принимающая отдельный параметр типа `a` и возвращающая что-то с типом `b`.

Здесь `a` может быть любого типа. Когда имя типа начинается с заглавной буквы, значит это явно заданный тип, например, `String`. Если имя типа написано в нижнем регистре, то это может быть любой тип. Здесь `a` может быть `String`, а может быть и `Int`.

Если вы видите `(a -> a)`, значит имеется в виду, что входящий и выходящий типы ОБЯЗАНЫ быть одинаковыми. Не имеет значения, какие они именно, главное, чтобы они соответствовали друг другу.

Но в случае с `map` у нас есть `(a -> b)`. Это означает, что хотя функция и МОЖЕТ возвращать разные типы, она также МОЖЕТ возвращать и одинаковые типы.

Но если тип `a` уже определён, он должен распространиться на всю остальную аннотацию \(_прим. пер., сигнатуру_\). Для примера, если `a` - `Int` и `b` - `String`, тогда аннотация будет подобна:

```text
(Int -> String) -> List Int -> List String
```

Здесь все типы `a` заменены на `Int`, а все `b` - на `String`.

Тип `List Int` означает список, содержащий типы `Int`, а `List String`означает список, содержащий `String`. Если вы используете обобщения типов данных в Java или других языках, тогда такая концепция должна быть вам близка.

Что теперь?

![](https://cdn-images-1.medium.com/max/1600/0*aSS_enpAghNQ2cG7.)

Теперь, когда вы изучили весь этот новый замечательный материал, вы, возможно, подумаете: «И что теперь? Как мне использовать это в моём обычном коде?».

Здесь возможны разные варианты. Если вы умеете программировать на чистом функциональном языке типа Elm или Haskell, тогда вам будет легко привести в действие механизмы всех этих идей и подобные языки позволят сделать это просто.

Если же вы умеете программировать только на императивном языке типа JavaScript \(на уровне, которым мы все должны владеть\), тогда вы можете продолжить использовать всё, что уже изучили, но теперь дисциплинируя себя.

#### Функциональный JavaScript <a id="63ec"></a>

![](https://cdn-images-1.medium.com/max/1600/0*ugZHX5OgQpRD8e3g.)

JavaScript имеет множество фич, позволяющих вам программировать на более функциональный манер. Полной чистоты не будет, но вы можете добиться некоторой неизменяемости с помощью самого языка и ещё большей с помощью библиотек.

Идеально не будет, но если вам нужно использовать функциональные возможности, тогда почему бы не привлечь некоторые преимущества языка?

#### Неизменяемость <a id="0462"></a>

Первая вещь, принимаемая во внимание — это неизменяемость. В ES2015 или ES6, как он ещё называется, появилось новое ключевое слово для объявления переменных — `const`. Оно означает, что если переменная была установлена однажды, она не может быть переопределена:

```javascript
const a = 1;
a = 2; // выбросит TypeError в Chrome, Firefox или Node
       // но не в Safari (на момент 10/2016)
       // (прим. пер., в Safari всё хорошо с версии 10.1)
```

Здесь `a` определена как константа и по этой причине не может быть изменена после установки. Вот почему выражение `a = 2` выбрасывает ошибку.

Проблема `const` в том, что в JavaScript она не заходит в своей идее так далеко, как должна. Следующий пример проиллюстрирует её предел:

```javascript
const a = {
    x: 1,
    y: 2
};
a.x = 2; // НЕТ ИСКЛЮЧЕНИЯ!
a = {}; // а вот это выбросит TypeError
```

Заметьте, что `a.x = 2` НЕ выбрасывает исключения. Единственное значение, остающееся неизменяемым с `const` – это сама переменная `a`. Всё, что `a` в себе определяет, может быть изменено.

Это ужасное разочарование, потому что отсутствие такого недостатка сделало бы JavaScript гораздо лучше.

Как же мы можем достичь полной неизменяемости в JavaScript?

К сожалению, это возможно только с помощью библиотеки [Immutable.js](https://facebook.github.io/immutable-js/). Она должна дать нам должный уровень неизменяемости, но, увы, её использование также сделает наш код больше похожим на Java, чем на JavaScript.

#### Каррирование и композиция <a id="a9a9"></a>

Раннее, в одной из предыдущих частей, мы научились писать каррированные функции. Вот более сложный пример по этому поводу:

```javascript
const f = a => b => c => d => a + b + c + d;
```

Обратите внимание, что нам пришлось написать каррированный фрагмент функции вручную.

И, чтобы вызвать `f`, мы должны написать:

```javascript
console.log(f(1)(2)(3)(4)); // выведет 10
```

Но круглых скобок здесь достаточно, чтобы заставить плакать Lisp-программиста.

Существует множество библиотек, облегчающих задачу каррирования. Одна из моих любимых — [Ramda](http://ramdajs.com/).

Использование Ramda теперь позволяет нам написать:

```javascript
const f = R.curry((a, b, c, d) => a + b + c + d);
console.log(f(1, 2, 3, 4)); // выведет 10
console.log(f(1, 2)(3, 4)); // также выведет 10
console.log(f(1)(2)(3, 4)); // также выведет 10
```

Определение функции стало выглядеть не намного лучше, зато теперь нам удалось избавиться от нужды во всех этих круглых скобках. Заметьте, что мы можем применять угодное нам количество параметров, когда вызываем `f`: столько же или всего несколько.

Используя Ramda, мы можем переписать функцию `mult5AfterAdd10` из [Части 3](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-3-d1f567656158) и [Части 4](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-4-58edb490d0da):

```javascript
const add = R.curry((x, y) => x + y);
const mult5 = value => value * 5;
const mult5AfterAdd10 = R.compose(mult5, add(10));
```

Пример показывает, что Ramda имеет множество вспомогательных функций для выполнения подобных задач, к примеру `R.add` и `R.multiply`, что означает для нас меньшее количество кода:

```javascript
const mult5AfterAdd10 = R.compose(R.multiply(5), R.add(10));
```

#### `map`, `filter`, `reduce` <a id="4e66"></a>

Ramda также имеет свои собственные версии `map`, `filter` и `reduce`. Несмотря на то, что эти функции находятся в `Array.prototype` в нативном JavaScript, их версии в Ramda каррированные:

```javascript
const isOdd = R.flip(R.modulo)(2);
const onlyOdd = R.filter(isOdd);
const isEven = R.complement(isOdd);
const onlyEven = R.filter(isEven);
```

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8];
console.log(onlyEven(numbers)); // выводит [2, 4, 6, 8]
console.log(onlyOdd(numbers)); // выводит [1, 3, 5, 7]
```

`R.modulo` принимает два параметра. Первый – это _**делимое**_ \(то, что мы делим\), второй – _**делитель**_ \(то, на что мы делим\).

Функция `isOdd` возвращает остаток от деления на два. При остатке от нуля чётного числа возвращается _**ложь**_, при остатке от единицы нечётного числа – _**истина**_. Мы перебросили \(_прим. пер., `flip`_\) первый и второй параметр из `modulo`, поэтому смогли установить `2`, как делитель.

Функция `isEven` – просто обратная \(_прим. пер., `complement`_\) версия `isOdd`.

Функция `onlyOdd` – _**фильтрующая**_ функция с предикатом \(функцией, возвращающей булево значение\) `isOdd`. Перед выполнением она ожидает последнее значение в переданном списке чисел.

Функция `onlyEven` – _**фильтр**_, использующий `isEven` в качестве предиката.

Когда мы передаём `number` в `onlyEven` и в `onlyOdd`, `isEven` и `isOdd`получают свои последние параметры и могут наконец-то выполниться, возвратив ожидаемые числа.

#### Недостатки JavaScript <a id="095b"></a>

![](https://cdn-images-1.medium.com/max/1600/0*5gaOmqxWBY2frZHh.)

Со всеми библиотеками и расширенными средствами языка, которые получил JavaScript, он остаётся страдать из-за того факта, что является императивным языком программирования, пытающимся быть всем и для всех.

Большинство фронтенд-разработчиков застряли на одном месте, используя JavaScript для браузера, потому что он долгое время оставался единственным вариантом. Но сейчас многие разработчики уходят от написания JavaScript-кода напрямую.

Вместо этого они пишут на других языках и компилируют или, выражаясь точнее, транспилируют их в JavaScript.

Одним из первым таких языков был CoffeeScript. Сейчас на вооружение Angular 2 \(_прим. пер., «сейчас» актуально для Angular 5_\) был принят TypeScript. Транспилятором для JavaScript является Babel.

Всё больше и больше людей прибегают к такому подходу в продакшене.

Но все эти языки начинали с JavaScript и только сделали его немного лучше. Почему бы не пойти до конца и не транспилировать JavaScript из чистого функционального языка?

#### Elm <a id="26a9"></a>

![](https://cdn-images-1.medium.com/max/1600/0*CzUT3MouQs2phEPx.)

В серии статей мы обращались к Elm, чтобы лучше понять функциональное программирование.

_**Но что такое Elm? И как мне использовать его?**_

Elm — это чистый функциональный язык, компилируемый в JavaScript, поэтому вы можете использовать его для создания веб-приложений, используя [The Elm Architecture](https://guide.elm-lang.org/architecture/), также называемую TEA \(эта архитектура вдохновила разработчиков Redux\).

У приложений, написанных на Elm, НЕ возникает никаких ошибок выполнения.

Elm используется в продакшене такими компаниями, как [NoRedInk](https://www.noredink.com/), где Эван Чаплики, создатель Elm, сейчас работает \(раньше он работал в [Prezi](https://prezi.com/)\).

Послушайте монолог [6 Months of Elm in Production](https://www.youtube.com/watch?v=R2FtMbb-nLs) от Ричарда Фельдмана, Elm-евангелиста из NoRedInk, для более подробной информации.

_**Должен ли я заменить весь свой JavaScript на Elm?**_

Нет. Вы можете постепенно заменять части кода. Чтобы узнать побольше, загляните в статью [How to use Elm at Work](http://elm-lang.org/blog/how-to-use-elm-at-work) из блога Elm.

_**Зачем учить Elm?**_

1. Программирование на чистом функциональном языке несёт в себе одновременно ограничение и освобождение. Ограничение заключается в ограничении ваших действий \(зачастую, это защита вас от вас самих\), но в тоже время вы освобождаетесь от ошибок и плохих архитектурных решений, так как Elm-приложения следуют The Elm Architecture, функционально-реактивной модели.
2. Функциональное программирование усовершенствует ваши навыки программиста. Все вышеупомянутые идеи — лишь верхушка айсберга. Вам действительно стоит увидеть их практическую реализацию, чтобы оценить насколько ваши программы уменьшатся в размере и вырастут в показателях стабильности.
3. JavaScript был изначально написан за десять дней и затем пропатчен в течение двух следующих десятков дней, чтобы превратиться в немного функциональный, немного объектно-ориентированный и полноценный императивный язык программирования. Elm был разработан с учётом накопленного за тридцать лет опыта развития Haskell-сообщества, опирающегося на десятилетия работы в области математики и информатики. The Elm Architecture \(TEA\) планировалась и улучшалась на протяжении многих лет и стала результатом личного достижения Эвана в функциональном реактивном программировании. Посмотрите [Controlling Time and Space](https://www.youtube.com/watch?v=Agu6jipKfYw), чтобы оценить уровень мышления, сформулировавшего эту архитектуру.
4. Elm был задуман для фронтенд-разработчиков. Он стремится сделать их жизнь проще. Посмотрите [Let’s Be Mainstream](https://www.youtube.com/watch?v=oYk8CKH7OhE), чтобы лучше понимать эту цель.

#### Будущее <a id="7418"></a>

![](https://cdn-images-1.medium.com/max/1600/0*SEv7HRk9MOBOdR_O.)

Невозможно предугадать, что принесёт с собой завтрашний день, но мы можем произвести некоторые грамотные предположения. Вот некоторые из моих:

> Произойдёт окончательный переход к языкам, компилируемым в JavaScript.

> Идеи функционального программирования, витающие вокруг да около на протяжении сорока лет, заново откроют себя, чтобы решить наши насущные проблемы сложности программного обеспечения.

> Состояние аппаратного обеспечения, в частности гигабайты дешёвой памяти и быстрые процессоры, сделает функциональные методы жизнеспособными.

> Центральные процессоры не станут работать быстрее, но количество ядер будет продолжать расти.

> Изменяющееся состояние будет осмысленно, как одна из основных проблем сложных систем.

Я написал эту серию статей, потому что верю, что за функциональным программированием будущее и потому что последнюю пару лет прикладывал все усилия, чтобы освоить его \(и я всё ещё учусь\).

Моей целью являлось помочь другим освоить все эти концепты легче и быстрее, чем мне самому, и помочь другим поднять их уровень в программировании, чтобы они стали более востребованными специалистами.

Даже если мой тезис о том, что Elm станет весомым языком в будущем, неверен, я могу сказать с достаточной уверенностью, что функциональное программирование и Elm находятся на одной траектории с движением будущего.

Я надеюсь, что после прочтения этих статей, вы чувствуете себя более уверенными в своих способностях и понимаете эти идеи.

Желаю вам удачи в ваших будущих начинаниях.  


{% embed url="https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-1-6ef98e90d58d" %}



