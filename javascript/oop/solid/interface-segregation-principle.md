---
description: Принцип разделения интерфейса
---

# Interface Segregation Principle

> _Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют._

Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов.

Рассмотрим интерфейс `Shape`:

![](https://cdn-images-1.medium.com/max/1600/1*JSBcFVAsRp6u2uubTo0oSw.png)

Он описывает методы для рисования кругов \(`drawCircle`\), квадратов \(`drawSquare`\) и прямоугольников \(`drawRectangle`\). В результате классы, реализующие этот интерфейс и представляющие отдельные геометрические фигуры, такие, как круг \(Circle\), квадрат \(Square\) и прямоугольник \(Rectangle\), должны содержать реализацию всех этих методов. Выглядит это так:

![](https://cdn-images-1.medium.com/max/1600/1*L6Np-mWXa_tA2ghupsIYog.png)

Странный у нас получился код. Например, класс `Rectangle`, представляющий прямоугольник, реализует методы \(`drawCircle` и `drawSquare`\), которые ему совершенно не нужны. То же самое можно заметить и при анализе кода двух других классов.

Предположим, мы решим добавить в интерфейс `Shape` ещё один метод, `drawTriangle`, предназначенный для рисования треугольников:

![](https://cdn-images-1.medium.com/max/1600/1*nqf3o-ahEang8xOCFnHsMQ.png)

Это приведёт к тому, что классам, представляющим конкретные геометрические фигуры, придётся реализовывать ещё и метод `drawTriangle`. В противном случае возникнет ошибка.

Как видно, при таком подходе невозможно создать класс, который реализует метод для вывода круга, но не реализует методы для вывода квадрата, прямоугольника и треугольника. Такие методы можно реализовать так, чтобы при их выводе выбрасывалась бы ошибка, указывающая на то, что подобную операцию выполнить невозможно.

Принцип разделения интерфейса предостерегает нас от создания интерфейсов, подобных `Shape` из нашего примера. Клиенты \(у нас это классы `Circle`, `Square` и `Rectangle`\) не должны реализовывать методы, которые им не нужно использовать. Кроме того, этот принцип указывает на то, что интерфейс должен решать лишь какую-то одну задачу \(в этом он похож на принцип единственной ответственности\), поэтому всё, что выходит за рамки этой задачи, должно быть вынесено в другой интерфейс или интерфейсы.

В нашем же случае интерфейс `Shape` решает задачи, для решения которых необходимо создать отдельные интерфейсы. Следуя этой идее, переработаем код, создав отдельные интерфейсы для решения различных узкоспециализированных задач:

![](https://cdn-images-1.medium.com/max/1600/1*IxbI6NibtnaPyoDkPqAKVg.png)

Теперь интерфейс `ICircle` используется лишь для рисования кругов, равно как и другие специализированные интерфейсы — для рисования других фигур. Интерфейс `Shape` может применяться в качестве универсального интерфейса.

