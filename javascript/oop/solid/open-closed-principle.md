---
description: Принцип открытости-закрытости
---

# Open-Closed Principle

> _Программные сущности \(классы, модули, функции\) должны быть открыты для расширения, но не для модификации._

Продолжим работу над классом `Animal`.

![](https://cdn-images-1.medium.com/max/1600/1*B2ej-q2xYqt5n6xMaT6FOQ.png)

Мы хотим перебрать список животных, каждое из которых представлено объектом класса `Animal`, и узнать о том, какие звуки они издают. Представим, что мы решаем эту задачу с помощью функции `AnimalSounds`:

![](https://cdn-images-1.medium.com/max/1600/1*eiz_U7YilT4VQUXqmIxRyg.png)

Самая главная проблема такой архитектуры заключается в том, что функция определяет то, какой звук издаёт то или иное животное, анализируя конкретные объекты. Функция `AnimalSound` не соответствует принципу открытости-закрытости, так как, например, при появлении новых видов животных, нам, для того, чтобы с её помощью можно было бы узнавать звуки, издаваемые ими, придётся её изменить.

Добавим в массив новый элемент:

![](https://cdn-images-1.medium.com/max/1600/1*KZmuEmaWIm33cVA2CM-MmA.png)

После этого нам придётся поменять код функции `AnimalSound`:

![](https://cdn-images-1.medium.com/max/1600/1*1_wo5O8p-IEzihuLmmcjTQ.png)

Как видите, при добавлении в массив нового животного придётся дополнять код функции. Пример это очень простой, но если подобная архитектура используется в реальном проекте, функцию придётся постоянно расширять, добавляя в неё новые выражения `if`.

Как привести функцию `AnimalSound` в соответствие с принципом открытости-закрытости? Например — так:

![](https://cdn-images-1.medium.com/max/1600/1*8Jes0v0icrczStJFfPXXIQ.png)

Можно заметить, что у класса `Animal` теперь есть виртуальный метод `makeSound`. При таком подходе нужно, чтобы классы, предназначенные для описания конкретных животных, расширяли бы класс `Animal` и реализовывали бы этот метод.

В результате у каждого класса, описывающего животного, будет собственный метод `makeSound`, а при переборе массива с животными в функции `AnimalSound` достаточно будет вызвать этот метод для каждого элемента массива.

Если теперь добавить в массив объект, описывающий новое животное, функцию `AnimalSound` менять не придётся. Мы привели её в соответствие с принципом открытости-закрытости.

Рассмотрим ещё один пример.

Представим, что у нас есть магазин. Мы даём клиентам скидку в 20%, используя такой класс:

![](https://cdn-images-1.medium.com/max/1600/1*WRtEcxjfidmYwDTa1v4XNw.png)

Теперь решено разделить клиентов на две группы. Любимым \(`fav`\) клиентам даётся скидка в 20%, а VIP-клиентам \(`vip`\) — удвоенная скидка, то есть — 40%. Для того, чтобы реализовать эту логику, было решено модифицировать класс следующим образом:

![](https://cdn-images-1.medium.com/max/1600/1*q9YdDcUbw6sVbjrXN5f-0w.png)

Такой подход нарушает принцип открытости-закрытости. Как видно, здесь, если нам надо дать некоей группе клиентов особую скидку, приходится добавлять в класс новый код.

Для того чтобы переработать этот код в соответствии с принципом открытости-закрытости, добавим в проект новый класс, расширяющий класс `Discount`. В этом новом классе мы и реализуем новый механизм:

![](https://cdn-images-1.medium.com/max/1600/1*X85RDmAaJpQ3qeIKl7-gHg.png)

Если решено дать скидку в 80% «супер-VIP» клиентам, выглядеть это должно так:

![](https://cdn-images-1.medium.com/max/1600/1*q948ZrrpjEbycsZUnuRKDw.png)

Как видите, тут используется расширение возможностей классов, а не их модификация.

