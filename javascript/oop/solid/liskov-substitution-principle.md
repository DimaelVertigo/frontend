---
description: Принцип подстановки Барбары Лисков
---

# Liskov Substitution Principle

> _Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов._

Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.

Рассмотрим применение этого принципа, вернувшись к примеру с классом `Animal`. Напишем функцию, предназначенную для возврата информации о количествах конечностей животного.

![](https://cdn-images-1.medium.com/max/1600/1*4XoqSj8-GAuN7Y2_F_fCLg.png)

Функция нарушает принцип подстановки \(и принцип открытости-закрытости\). Этот код должен знать о типах всех обрабатываемых им объектов и, в зависимости от типа, обращаться к соответствующей функции для подсчёта конечностей конкретного животного. Как результат, при создании нового типа животного функцию придётся переписывать:

![](https://cdn-images-1.medium.com/max/1600/1*q8LGkqcWeUZ4KMYmgTXW8A.png)

Для того чтобы эта функция не нарушала принцип подстановки, преобразуем её с использованием требований, сформулированных Стивом Фентоном. Они заключаются в том, что методы, принимающие или возвращающие значения с типом некоего суперкласса \(`Animal` в нашем случае\) должны также принимать и возвращать значения, типами которых являются его подклассы \(`Pigeon`\).

Вооружившись этими соображениями мы можем переделать функцию `AnimalLegCount`:

![](https://cdn-images-1.medium.com/max/1600/1*7dIglq-wS9bddKQ0YlUixg.png)

Теперь эта функция не интересуется типами передаваемых ей объектов. Она просто вызывает их методы `LegCount`. Всё, что она знает о типах — это то, что обрабатываемые ей объекты должны принадлежать классу `Animal` или его подклассам.

Теперь в классе `Animal` должен появиться метод `LegCount`:

![](https://cdn-images-1.medium.com/max/1600/1*2L0QDCFWihrPIEpk66PVng.png)

А его подклассам нужно реализовать этот метод:

![](https://cdn-images-1.medium.com/max/1600/1*PBp00ezb_0YXO9vc3im7GQ.png)

В результате, например, при обращении к методу `LegCount` для экземпляра класса `Lion` производится вызов метода, реализованного в этом классе, и возвращается именно то, что можно ожидать от вызова подобного метода.

Теперь функции `AnimalLegCount` не нужно знать о том, объект какого именно подкласса класса `Animal`она обрабатывает для того, чтобы узнать сведения о количестве конечностей у животного, представленного этим объектом. Функция просто вызывает метод `LegCount` класса `Animal`, так как подклассы этого класса должны реализовывать этот метод для того, чтобы их можно было бы использовать вместо него, не нарушая правильность работы программы

